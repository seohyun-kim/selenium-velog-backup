---
title: "[정보보호론] 20장. 대칭 암호와 메세지 무결성"
description: "대칭암호  파이스텔  💡 파이스텔 구조 기반DES는 평문 64bit, Key 56bit, 16 라운드, 매 라운드마다 16개의 서브키 만듦3DES 는 3개의 key를 사용하고 DES를 3번 수행3DESFIPS에서 승인한 대칭 블록 알고리즘56비트 단일 키를 갖는 원래"
date: 2022-04-27T10:11:25.275Z
tags: []
---



## 20.1 대칭 암호 원칙 `p.706`

- 대칭암호
    
    ![](/images/602cd51c-c263-400e-be62-3870cf90d2a5-image.png)

    
<br/>  

### 파이스텔 사이퍼 구조(Feistel Cipher Structure) `p.710`

- 파이스텔
    
    ![](/images/1b004862-f632-437e-9349-8764f34f7d7a-image.png)

    
<br/>  
<br/>  

## 20.2 DES `p.711` —잘안씀


> 💡 파이스텔 구조 기반

![](/images/f10f29ce-d4eb-4772-beea-42f59cc927c0-image.png)


![](/images/8d307d48-1080-462e-850b-02116e00b1fa-image.png)


![](/images/12b108b7-3ac1-4a32-a244-87e7fef6851a-image.png)


- DES는 `평문 64bit`, `Key 56bit`, `16 라운드`, 매 라운드마다 16개의 서브키 만듦
- 3DES 는 3개의 key를 사용하고 DES를 3번 수행

- 3DES
    - FIPS에서 승인한 대칭 블록 알고리즘
    - 56비트 단일 키를 갖는 원래의 기존 시스템만을 위한 표준 아래 허용, 새로 구매하려면 3DES지원해야함
    - 기존 DES 시스템을 보유한 정보 조직에서는 3DES로 이전이 격려됨
    - 3DES와 AES는 FIPS에서 승인한 알고리즘으로, 3DES가 AES로 점진적으로 이동하면서 공존할 것으로 기대됨

<br/>  
<br/>  

## 20.3 AES `p.713` 

> 💡 파이스텔 구조 ❌
>각 라운드 마다 대치와 치환을 사용함으로써 전체 데이터 블록을 병렬로 처리
>SPN 기반임 ⭕


![](/images/6da33e48-9b88-4248-8047-3b63521ddbdc-image.png)


- 각 라운드는 4 스테이지로 되어있음
    - `Substitute bytes`: 블록 바이트 단위 대치를 위해 s-box라 불리는 표를 사용
    - `Shift rows`: 열 단위로 수행되는 간단한 치환연산
    - `Mix Columns`: 한 열에 잇는 각각의 바이트를 그 열에 있는 모든 바이트의 함수로서 변경하는 대치
    - `Add Round Key`: 현재의 블록과 확장된 키의 일부분과 단순히 비트 단위로 XOR한 것


<br/>  

![](/images/434ef640-2970-4db7-9ece-5995bc9df71c-image.png)

<br/>  

### 알고리즘 상세 `p.717`

![](/images/cfe256b0-99b2-4fb5-a621-1e8dbe53bcf0-image.png)

- 테이블에서 치환 값 찾아봄

<br/>  

![](/images/83cf865f-5a2a-42fa-a6f9-8b7fe479b089-image.png)

- 한 바이트씩 Left Rotate함

<br/>  

![](/images/99629b8c-16f6-436a-9159-cb4bcdb93218-image.png)


  ![](/images/82e0b5cc-03cf-4629-b8b9-40b1f35da267-image.png)
  - 행렬을 섞어 줌 : 행렬 * 벡터 과정을 통해 바꿔줌
  - 역행렬이 존재해야함

<br/>  


![](/images/c9b5f5c3-64f5-4a36-b423-ed95316ac7c9-image.png)


- 상태와 라운드 키 값을 XOR함
- 역방향 변환은 순방향 변환가 동일함
- 비교적 간단하며 상태의 모든 비트에 영향을 미침
- 라운드 키 함수의 복잡도와 다른 단계의 복잡도가 더해져 AES의 안전성을 보장

<br/>  


### 키분배 `p.732`

![](/images/810ebb98-b8f7-4f57-9fb7-1d3ad21934dc-image.png)

- 대칭 키 암호화 방식은 키를 어떻게 나누어 갖느냐가 중요

<br/>  
<br/>  

## 20.5 블록 사이퍼 운영 모드 `p.724`

![](/images/6be8df9d-aaaa-4c6f-8369-3b94f535b45b-image.png)


- 블록 사이퍼
    - 한번에 한 블록의 원소들을 입력으로 받아 처리한 다음, 각 입력블록에 대한 출력을 산출
- 스트림 사이퍼
    - 입력 원소들을 연속적으로 처리하면서 한 번에 하나의 원소를 출력으로 산출
- 블록사이퍼 5가지 운영 모드
    - ECB
    - CBC
    - CFB
    - OFB
    - CTR

![](/images/16ee7dc1-ad53-4fa1-9d5b-303f42133e73-image.png)

![](/images/e30915e5-322c-4433-824c-f0aa87ec44de-image.png)


<br/>  

### ECB `p.724`

![](/images/235c7695-7550-4fd4-91db-6026e66563e5-image.png)


- 평문이 한번에 b비트씩 처리되며, 평문의 각 블록은 동일한 키를 사용하여 암호화 됨
- 같은 텍스트에 같은 키를 사용하면 암호문이 같아서 보안상 취약
- 거대한 코드 북이있음

<br/>  

  
### CBC `p.725`

![](/images/88e76919-be06-429f-81ad-303251ce899e-image.png)


- 앞 블록과 암호문으로 고리를 연결
- 항상 같은 암호문이 아니라 보안상 안전
- 비트의 반복되는 패턴은 노출되지 않음
- **한 암호문 블록에서 오류 생긴 경우 이후 블록에 영향 미치게 되어 에러 전파**
- IV는 송신자 수신자 모두에게 알려져야 하는데 보안을 위해 키처럼 보호되어야 함. ⇒ ECB 암호화를 통해 보냄으로써 이루어짐
- 미리 구해 놓을 수 없음

<br/>  

### CFB `p.727`

![](/images/4dc9605f-e668-4fb6-9c5d-289b94fcaf92-image.png)


- IV를 암호화 함
- 암호화 한 IV와 플레인 텍스트를 XOR해서 암호문을 만듦
- 그 암호문을 연결해줌
- **복호화 모듈이 필요없음!😊**
- 단점: 재전송 공격이 가능함☹
- CFB 스트림으로도 가능하다!
- 한꺼번에 미리 구해 놓을 순 없음ㅜ

<br/>  


### OFB

![](/images/ed34c022-4866-4db4-81f0-3ecd2eb2b56a-image.png)


- **XOR 연산 전에 FeedBack 하면 OFB**
- **OFB는 재전송 공격 불가능!!**
- **전 처리 가능함!!**

<br/>  


### CTR(Counter) `p.729`

![](/images/791a374b-0d51-4a8e-8279-66e9a3608330-image.png)


- **병렬처리 가능 (동시 암호화 가능)**
- **이전 블록과 관계 X**
- **복호화 모듈 필요 없음!!😊**
- 논스 값이 주어지면 N번째 블록에서 암호화 할 카운터 값이 정해져 있음
- 무선 환경에서 많이 사용
- 임의 접근 가능


![](/images/fbe5a471-a93e-4c6a-b259-220a496bd3fe-image.png)


